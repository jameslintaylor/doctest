(ns jameslintaylor.doctest.format
  "Docstring formatting utilities."
  (:require
   [cljfmt.main :as cljfmt]
   [clojure.string :as string]
   [clojure.test :as test]
   [jameslintaylor.doctest.parse :as parse]))

(def ^:private ^{:arglists '([fmt & args])} format-cljfmt
  (comp (partial #'cljfmt/reformat-string {}) format))

(defn wrap
  [n form]
  (with-meta form {::wrap n}))

(defmulti form-str
  "Given a form, return a formatted string suitable to be written to a
  clojure test file.

  If form is sequential, the :jameslintaylor.doctest.format/wrap
  metadata determines where to begin adding new lines.

  Usage:

  nil and literal strings are handled appropriately
  => (form-str '(foo nil \"bar\"))
  \"(foo nil \"bar\")\"

  elements after :jameslintaylor.doctest.format/wrap are on new lines
  => (form-str (wrap 2 '(foo bar baz)))
  \"(foo bar\n     baz)\""
  type)

(defn- seq-form-str [seq-form]
  (let [nwrap (::wrap (meta seq-form) (count seq-form))
        [h t] (split-at nwrap seq-form)]
    (format-cljfmt "(%s%s)"
                   (string/join " " (map form-str h))
                   (apply str (map (comp (partial str "\n") form-str) t)))))

(defmethod form-str clojure.lang.Cons
  [form]
  (seq-form-str form))

(defmethod form-str clojure.lang.IPersistentList
  [form]
  (seq-form-str form))

(defmethod form-str java.lang.String
  [form]
  (format "\"%s\"" form))

(defmethod form-str java.util.regex.Pattern
  [form]
  (format "#\"%s\"" form))

(defmethod form-str nil
  [_]
  "nil")

(defmethod form-str :default
  [form]
  (str form))

(def ^:private ^:dynamic *resolve-ns*)

(def ^:private ^:dynamic *refer-syms*)

(defn- resolve-sym
  [sym]
  (if (contains? *refer-syms* sym)
    sym
    (if-let [{:keys [name ns]} (meta (ns-resolve *resolve-ns* sym))]
      (symbol (str ns) (str name))
      sym)))

(defn- resolve-all
  [expr]
  (if (seq? expr)
    `(~@(map resolve-all expr))
    (if (symbol? expr)
      (resolve-sym expr)
      expr)))

(defn assertion-form
  [assertion]
  (let [{:keys [expected
                expr
                msg]} assertion
        eq-form       (wrap 2 `(~'= ~(resolve-all expected) ~(resolve-all expr)))]
    (if msg
      (wrap 2 `(~'is ~eq-form ~msg))
      `(~'is ~eq-form))))

(defn test-form
  [var-name assertions]
  (wrap 3 `(~'deftest ~(symbol "^:doctest") ~(symbol (str var-name "-test"))
            ~@(map assertion-form assertions))))

(defn ns-form
  []
  (wrap 2 `(~'ns ~(symbol (str *resolve-ns* "-doctest"))
            "Generated by doctest."
            ~(wrap 1 `(:require
                       [~'clojure.test :refer [~'deftest ~'is]]
                       [~(symbol (str *resolve-ns*)) :refer [~@(sort *refer-syms*)]])))))

(defn test-file-str
  [ns]
  (when-let [sym-assertions (->> (ns-interns ns)
                                 (reduce-kv
                                  (fn [a sym var]
                                    (if-let [assertions (parse/doctest-assertions var)]
                                      (assoc a sym assertions)
                                      a))
                                  {})
                                 not-empty)]
    (binding [*resolve-ns* ns
              *refer-syms* (set (keys sym-assertions))]
      (format "%s%s"
              (form-str (ns-form))
              (apply str (map (comp (partial str "\n\n")
                                    form-str
                                    (partial apply test-form))
                              sym-assertions))))))
